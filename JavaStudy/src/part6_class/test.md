## 클래스

<h4> 💡 객체 지향 프로그래밍 (OOP : Object-Oriented Programming) </h4>

<ul>
	<li> 객체(설계도로부터 만들어진 것 => 클래스로부터 만들어진 객체 : 해당 클래스의 인스턴스)
		<ul> 
			<li> 객체 지향 프로그래밍(OOP): 프로그램을 개발하는 기법으로, 부품에 해당하는 객체들을 먼저 만들고 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법 </li>
			<li> 객체(Object): 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 자신의 속성을 가지고 있으면서 식별 가능한 것 
				<ul> ex) 물리적으로 존재하는 자동차, 자전거, 책, 사람 & 추상적인 학과, 강의, 주문 등 모두 객체가 됨 </ul>
			</li>
			<li> 객체는 속성(필드)과 동작(메소드)으로 구성되어 있음 </li>
			<li> 객체 모델링 : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것 </li>
			<li> 객체의 상호작용: 객체와 객체 간의 상호작용으로 이루어져 있음 </li>
			<li> 객체들 사이의 상호작용 수단은 "메소드" // 객체가 다른 객체의 기능을 이용하는 것 : "메소드 호출" </li>
			<li> 메소드 호출 형태 ➡️ 리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ... ); // int result = Calculator.add(10, 20); </li>
		</ul>
	</li> 
</ul>

<ul>
	<li> 클래스 (자바에서의 설계도)  
		<ul>
			<li> 객체 생성 ➡️ new 클래스();
				<ul>
					<li> new 연산자로 생성된 객체는 힙 영역에 생성시킨 후 객체의 번지를 리턴하도록 되어 있음 </li>
					<li> 변수를 통해 객체 사용이 가능함 ➡️  클래스 변수 = new 클래스(); ➡️ ex) Car car = new Car(); </li>
				</ul>
			</li>
			<li> 클래스의 구성 멤버
				<ul>
					<li> 필드 
						<ul>
							<li> 객체의 데이터가 저장되는 곳 & 생성자와 메소드 전체에서 사용됨 & 객체와 함께 존재 & 변수와 다름 XX </li>
							<li> 변수 : 생성자와 메소드 내에서만 사용되고, 생성자, 메소드가 실행 종료되면 자동 소멸됨)</li>
						</ul>
					</li>
					<li> 생성자 
						<ul>
							<li> 객체 생성 시 초기화 역할 담당 & 필드 초기화 or 메소드 호출해서 객체 사용 준비 </li>
							<li> 클래스 이름과 동일 & 리턴 타입 없음 </li>
							<li> 클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자에서도 public이 붙지 않음</li>
							<li> 명시적으로 생성자를 선언하는 이유 : 객체를 다양한 값으로 초기화하기 위해서 </li>
						</ul>
					</li>
					<li> 메소드
						<ul>
							<li> 객체의 동작에 해당하는 실행 블록 {} </li>
							<li> 필드를 읽고 수정하는 역할 & 다른 객체를 생성해서 다양한 기능을 수행 </li>
							<li> 객체 간의 데이터를 전달하는 수단 (외부로부터 매개값을 받아 실행에 이용하고, 실행 후 결과 값을 외부로 리턴할 수 있음) </li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

<h4> ⭐⭐ 생성자 오버로딩(Overloading)과 생성자 오버라이딩(Overriding)⭐⭐ </h4>

<ul>
	<li> 생성자 오버로딩(Overloading)
		<ul> 하나의 클래스에 같은 이름의 메소드를 여러 개 정의하는 것 
			<ul> ❓ 오버로딩 조건 
				<li> 메소드 이름이 같아야 함 </li>
				<li> 매개 변수를 달리하는 생성자를 여러 개 선언하는 것 (매개변수의 타입, 개수, 순서가 다르게 선언) - 리턴 타입은 오버로딩 구현과 관계 없음 </li>
				<li> 생성자에서 다른 생성자 호출 : this() => 반드시 생성자의 첫 줄에서만 허용됨 
					<ul> 🌀호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행함</ul>
				</li>	
			</ul>
		</ul>
	</li>
</ul>

<ul> 
	<li> 오버라이딩(Overriding) = 메소드 재정의
		<ul> 상속을 했을 때 자식 클래스에서 부모 클래스의 메소드를 자식 클래스에 맞게 다시 정의하는 것
			<ul> ❓ 오버라이딩 조건 
	                	<li> 선언부가 같아야 함 = 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 목록)를 가져와야 함 </li>
		        	<li> 접근 제한을 더 강하게 (좁은 범위로) 재정의 할 수 없음 </li>
            			<li> 새로운 예외(Exception)를 throws 할 수 없음 = 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없음 </li>
			</ul>
		</ul>
	</li>
</ul>

<h4> 💡 인스턴스멤버와 정적멤버 (클래스는 1개, 클래스에서 만들어진 객체는 여러 개 가능) </h4>
<ul>
	<li> 인스턴스 멤버 
		<ul>
			<li> 객체마다 가지고 있는 멤버 (객체 안에 존재하는 것) </li>
		</ul>
	</li>
</ul>
<ul>
	<li> 정적 멤버 
		<ul>
			<li> 클래스에 위치시키고 객체들이 공유하는 멤버 (객체 안에 들어가는 것이 아니므로 객체를 생성하지 않고 필드와 메소드 사용 가능) </li>
			<li> 객체 자신의 참조인 this 키워드도 사용이 불가능함 </li>
		</ul>
	</li>
</ul>

<h4> ⭐⭐ 싱글톤 (Singleton) ⭐⭐ </h4>
<ul>
	<li> 싱글톤 : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 단 하나의 객체만 생성함
		<ul>
			<li> 클래스 외부에서 new 연산자로 생성자 호출을 할 수 없도록 막아야함 (생성자 호출한 만큼 객체 생성되기 때문) 
				<ul> 단, 클래스 내부에서는 new 연산자로 생성자 호출 가능함! </ul>
			</li>
			<li> 생성자를 외부에서 호출할 수 없도록 하기 위해 생성자 앞에 private 접근 제한자 붙여줌 </li>
			<li> 외부에서 객체를 얻는 유일한 방법은 getInstance()메소드를 호출하는 방법 - 단 하나의 객체(정적 필드에서 참조하고 있는 자신의 객체)만 리턴함.
				<ul> 클래스 변수1 = 클래스.getInstance(); </ul>
				<ul> 클래스 변수2 = 클래스.getInstance(); </ul>
				<ul> ➡️ 변수 1, 변수 2는 같은 객체를 참조함 (= 같은 번지수 가짐) </ul>
			 </li>
		</ul>
	</li>
</ul>
<h4>  💡 final 필드와 상수 </h4>
<ul> 📕 final 필드 : 최종적인 필드 = 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중 수정이 불가능함 ❌❌
	<ul> 
		<li> final 타입 필드 [= 초기값]; </li>
		<li> 객체마다 저장되고, 생성자의 매개값을 통해 여러 가지 값을 가질 수 있음 </li>
	</ul>
</ul>
<ul> 
	<ul> final 필드의 초기값 주는 방법
		<li> 1. 필드 선언 시 주는 방법 - 단순 값일 때 사용 </li>
		<li> 2. 생성자에서 주는 방법 - 복잡한 초기화 코드가 필요하거나 객체 생성 시 외부 데이터로 초기화해야 할 때 사용 </li>
	</ul>
</ul>
<ul> 📘 상수 : 불변의 값을 저장하는 필드
	<ul>
		<li> static final 타입 상수 = 초기값; </li>
		<li> 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러 가지 값으로 초기화 될 수 없음 ❌❌ </li>
		<li> 상수는 static 이면서 final임 (객체마다 존재하지 않고 클래스에만 존재함 / 한 번 초기값이 저장되면 변경 불가능) </li>
		<li> 상수 이름은 모두 대문자로 작성해야함 </li>
	</ul>
</ul>
<h4>  ⭐⭐ 패키지와 접근 제한자 ⭐⭐ </h4>
<ul>
	<li> 접근 제한자 (Access Modifier) 
		<ul>
			<li> 1. public 접근 제한자 : 외부 클래스가 자유롭게 사용 가능 (어디서든 가능) </li>
			<li> 2. protected 접근 제한자 : 같은 패키지 내 or 다른 패키지에서 속한 클래스가 해당 클래스의 자식 클래스라면 생성자 호출 가능  </li>
			<li> 3. private 접근 제한자 : 같은 클래스 내에서만 사용 가능 / 같은 패키지 or 다른 패키지에서 둘 다 생성자 호출 불가능X - Car myCar = new Car(); 객체 생성 불가능!! </li>
			<li> + 4. default 접근 제한자 : 같은 패키지에 소속된 클래스에서만 사용할 수 있음 (public을 생략하면 default 제한 가짐)</li>
		</ul>
	</li>
</ul>
<ul>
	<li>  ⭐⭐ Getter와 Setter 메소드 ⭐⭐  
		<ul>
			<li> 객체지향프로그래밍 -> 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막음 (객체의 무결성이 깨지는 것을 방지) </li>
			<li> Getter : 외부에서 객체의 데이터(저장되있는 곳 : 필드)를 읽을 때 getter 메소드 사용 / getMid와 같이 get 다음엔 대문자로 시작  </li>
			<li> Setter : 필드 값을 변경할 때 setter 메소드 사용 (메소드는 매개값을 검증해서 유효한 값만 객체의 필드로 저장할 수 있기 때문) / setMid와 같이 set 다음엔 대문자로 시작 </li>
			<li> + 필드 타입이 boolean일 경우에는 Getter는 get이 아닌 is로 시작함 (ex.getStop이 아닌 isStop 메소드가 됨) </li>
			<li> + 외부에서 필드 값을 읽을 수만 있고 변경하지 못하도록 하려면(읽기 전용) Getter 메소드만 선언하거나 Setter 메소드가 private 접근 제한을 갖도록 선언 해야함 </li>
		</ul>
	</li>
</ul>

